### 垃圾收集器与内存分配策略

#### 3.1如何确定对象已死

* 引用计数: A对象引用B对象时,B对象的引用计数+1
  * 缺点: 当出现循环引用时就变得难以区分
* 可达性分析算法: 通过一系列称为"GC Roots"的对象为起始向下搜索,凡是在这条搜索路径上的皆为存活对象,反之即为垃圾对象
  * 栈帧中的局部变量表中引用的对象
  * 方法区中静态属性引用的对象
  * 方法区中常量引用的对象,StringTable
  * 本地方法栈中的JNI所引用的对象
  * JVM内部的引用,基本数据类型对应的class对象,常驻的异常,系统加载器
  * 被同步锁持有的对象(synchronized)】
  * J反应JVM内部情况的MXBean,JVMTI中注册的回调,本地代码缓存等

#### 3.2对象已死

* 当对象被JVM第一次标记为需要被回收时,会判断是否需要执行finalize(),如果对象需要执行finalize()，就将其加入到F-Queue队列中,交由JVM自动建立的,低优先级的Finalizer线程去执行它的finalize(),如果这个对象此时与GCRoots引用链重新建立起关联的话,那么在JVM对F-Queue的第二次小规模标记中从“即将回收”的集合移除出去
  * 是否有必要执行finalize(): 对象是否重写finalize()，对象是否已经被虚拟机调用过
  * finalize的不保证执行结束: 假设某个对象的finalize()是一个死循环,那么将导致整个finalizer线程无法正常执行

#### 3.3回收方法区

**回收方法区内的类型**

* 该类的所有实例均被回收: 没有任何该类及其子类的实例
* 加载该类的类加载器已经被回收
* 该类对应的java.lang.Class对象没有被任何地方所引用,也就是无法在任何地方通过反射访问该类

#### 3.4垃圾收集算法

* 分代收集假说

  * 弱分代假说: 大多数的对象是朝生夕死的
  * 强分代假说: 熬过越多次GC的对象就越难以消亡
  * 跨代引用假说: 跨代引用相对于同代引用来说占极少数(存在引用关系的两个对象应当趋向于一起出生一起消亡)

* GC分类

  * MinorGC/YoungGC: 年轻代GC
  * MajorGC/OldGC: 老年代GC
  * MixGC: 整个年轻代与部分老年代GC
  * FullGC: 整堆GC

* GC算法

  * 标记-清除: 缺点在于如果大量对象需要进行清理的话就需要进行大量的标记和清除动作,**会造成大量的内存碎片**

  * 标记-复制算法: 缺点如果大量对象存活那么就需要移动大量对象,**需要开辟额外的空间来进行对象复制**

  * 标记-整理: 相比“标记-清除”,避免了内存碎片的问题,**但也增加了GC时的指针转移维护成本**

  * ```txt
    标记-清除与标记-整理相比: 前者的高效体现在GC时(直接清除,不需要维护指针转移的负担),后者的高效体现在分配内存时(规整的内存空间,不需要维护空闲列表)。但是对于大多数应用来说,程序大部分时间是在和内存打交道而不是GC,而程序的吞吐量也就受限于分配内存时的效率了。
    
    CMS采取了一种和稀泥的方式,在程序运行的大部分时间内,采取了标记-清除,而在内存不足以分配对象时,在调度parallel进行标记-整理
    ```

  #### HotSpot算法实现
  
  * 根节点枚举--OopMap
    * 如果再进行GC时才从全局性引用中去获取GCRoots,那么会导致STW的时间变得漫长,所以HotSpot采取了OopMap的解决方案。但执行线程达到安全点时,记录每个栈帧上的Oop(普通对象指针)变化情况。这样就避免在GC时从方法区等GCRoots开始查找,直接从OopMap中开始遍历。
    
  * 安全点
    
    * 为每条指令生成OopMap记录是耗时耗内存的行为,所以合理的方式是以一定的间隔来执行OopMap记录扫描
    * 何时才是记录OopMap的时机?不让用户线程有明显感知的时候
      * 方法跳转,不定循环,异常跳转
    * 到了安全点之后如何记录OopMap?
      * 抢先式中断: 首先暂停所有用户线程,再检查用户线程是否到达安全点,如果没到达就恢复线程运行值安全点
      * 主动式中断: 当GC线程需要进行GC时设置标志位,用户线程在执行的过程中不断轮询该标志位
        * 轮询的位置与安全点重合,附加在堆上分配内存的时候(new 。。。)
        * 如果设置了该标志位,则触发Os的缺页异常,由中断处理程序挂起该线程
    
  * 安全区
    
    * 对于不处于运行状态的线程(sleep,wait)如何操作？
      * 即将进入安全区的用户线程开始记录OopMap,离开安全区(恢复线程执行)的时候检测GC线程是否需要STW
    
  * 记忆集和卡表
    
    * 卡表是记忆集的一种实现方式
    
    * 记忆集记录了非收集区域指向收集区域的信息
    
      ```
      假设非收集区域Area_A存在对象A,其存在跨代引用,A在堆中的地址位0X0000 0001,
      那么该区域的卡表CARD_TABLE[0X0000 0001>n]=1,标记为存在跨代引用
      那么当其他收集区域发生GC时只需要将该Area_A所标识出的卡页包含的对象进行扫描即刻,可不需要对整个Area_A进行扫描
      ```
    
    * 如何维护卡表: 采用写屏障(类AOP的方式),当执行赋值命令时采取AOP的方式标记卡表
    
  * 三色标记:
    
    * ```
      白色: 该对象未被垃圾收集器标记过
      黑色: 已经被垃圾收集器标记过,且所有字段都已被扫描
      灰色: 已经被垃圾收集器标记过,但是至少一个字段引用未被扫描
      ```
    
    * 浮动垃圾: 在用户线程与GC线程并发执行的过程中,标记为黑色的对象,与引用链上失去联系,按道理应该被清除,但是不清楚也没关系,只不过浪费了内存,但是不会对程序造成影响
    
    * 存活对象标记为垃圾: 这种情况存在与用户线程并发执行的过程中,1)黑色对象重新指向了一个白色对象,并且2)灰色对象删除对白色对象的引用
    
      * 增量更新: 破坏第一个条件,当产生黑色对象指向白色对象的引用时,讲该黑色对象记录下来,等并发扫描结束时,再以这些被记录的黑色对象为根在扫描一次
      * 原始快照: 破坏第二个条件,当灰色对象删除对白色对象的引用时。将这个要删除的引用关系记录下来,等并发扫描结束之后,对这些记录下来引用关系的灰色对象为根重新扫描一遍(怎么来理解？ 就相当于本来是要废弃从灰色对象到白色对象的引用关系的,但是GC此时利用写前屏障将本该删除的引用关系保留下来,然后等并发扫描结束,重新沿着这条本该被废弃的路径重新扫描一遍,就相当于保存了最开始的那一份副本,也必不可免的产生了浮动垃圾)

#### 3.5垃圾收集器

**serial: **使用单CPU单线程的GC收集

**ParNew:** 可使用多核心,多线程的并行GC收集,但是在单核物理机上,他的性能并不比serial高(线程上下文切换的性能损耗)

**Parallel Scavenge: **大部分的功能与ParNew类似,但是这是一款更加关注与程序吞吐量的GC,怎么来理解呢,就是当设置**-XX:+UseAdaptiveSizePolicy**时,GC将动态调整新生代大小,eden与Survivor的比例,晋升老年代对象大小的参数以达到较高的吞吐量 => 如果eden较大,虽然STW的时常更长,但是GC的次数也变少了。晋升老年代的年龄变小了,那新生代保留的存活对象是不是少了 => 这是举了一些特例,实际情况需要结合具体数值进行计算,但是大体上是这样的

**CMS: **并发标记清除(concurrent mark sweep)，1）初始标记(STW)只标记与GCRoots直接关联的对象,2）并发标记(采取增量更新),与用户线程交互指向,gc线程负责继续标记,用户线程继续处理业务程序,3）重新标记(STW),在这个阶段负责将第二个阶段产生的垃圾继续清除,4）并发清楚,与用户线程交替指向,用户线程继续处理业务程序,GC线程负责回收垃圾

```
CMS的弊端:
1）对处理器敏感,需要占用(CPU核心+3)/4的线程数,那么当处理器核心越少时，用于处理用户线程的核心就越少(虽然是一样的百分比,但是在单核心的情况下就占用了完整的一个核心，那么当处于并发标记阶段时,还是占用了用户线程的算力，即使是采取了抢占式调度的方式,那么由于增加了线程切换的次数,那么总体上就更加耗时了)
2）浮动垃圾,在并发标记与并发清除阶段,用户线程还在执行,那么就意味着有可能标记为黑色对象在以上2个阶段中不再被引用链上的任何对象所引用,那么就产生了浮动垃圾(三色标记只处理“存活对象标记为垃圾”这种情况)。所产生的浮动垃圾就只能交由下一次GC处理
3）内存使用效率,这里结合2点来表述,
	 * 内存预留,用于CMS是一款并发GC,所以为了在并发标记和并发清理的阶段需要为用户程序预留足够的空间来分配对象,如果老年代对象占用整个其空间的68%(JDK5默认设置),相对容易触发GC,就代表GC频率增加了。如果为92%(JDK6),这时如果预留的8%无法为并发执行的用户线程分配对象的话,就会导致Concurrent mode failure,而不得不调用serial Old来重新对老年代进行回收此时会产生STW冻结用户线程,那样停顿的时间就更长了
	 * 内存碎片,CMS采取的回收策略是标记清除，这就意味着在CMS的执行期间会产生大量的内存碎片,当分配大对象时就有很大可能会遇到总的内存空间是足够的,但是缺无法找到连续的空间来为大对象分配,这时就不得不进行一次FullGC来进行整堆扫描并整理内存碎片,由于内存整理需要移动存活对象,那么就需要STW暂停用户线程，那么用户线程的暂停时间就变长了
```

```tex
答自己的疑
Q: 并发清理会造成用户程序引用不到该清理对象的情况吗？ 
A: 不会,GCRoots包含了方法区静态属性,所有JVM栈栈帧中的引用,那么从不在这些从GCRoots衍生出去的引用链条内的对象，那确实是垃圾,1)首先在由JVM栈栈帧所组成的方法调用链中不会被使用到,方法区中的静态属性也不会使用到，也就是说在safepoint时不被方法调用链和静态属性所引用的对象,后续也根本无法获取到该对象,所以它就该被回收
```

**G1:**基于Region的内存布局形式,建立起停顿预测模型的收集器(在指定长度为M毫秒的时间段内,消耗在GC上的时间大概率不超过N毫秒这样的目标)

* **G1知识点**

  * ```
    1.G1将连续的Java Heap划分为多个大小相等的独立区域(region).对于每个region都有一个tag标识(Eden,Survivor,Old,Humongous),对于超过Region大小50%的对象被认定为大象会被分配至由多个Region组成的Humongous区中。一个时刻一个Region只能是一种区域,但随着GC的执行,这些Region的tag会变化
    
    2.G1的可预测停顿时间模型,是建立在G1将Region作为单次回收的最小单元,每次收集都是Region的整数倍。G1根据每个Region的价值进行回收(价值=回收获得的空间 和 回收所需要的时间)，G1去跟踪每个Region的价值,并在后台维护一个优先级列表，每次根据用户设定允许的收集停顿时间(-XX:MaxGCPauseMillis,默认200ms)，优先处理回收价值高的那些region
    ```

* **G1的技术实现**

  * ```
    1.记忆集(Rset): 每个Region维护着一个数据结构类似于Hash表的记忆集
                   <Key=引用自己的别的Region的起始地址,Value=引用自己的那些对象的卡表编号的集合>
                   当GC时,可以根据Key找到Region,根据Value找到CardPage,
                   向上搜索完毕后将这些cardPage内的对象加入GcRoots集合中
    2.脏卡队列(Dirty-Queue): 将脏卡队列分成四个区域(白,绿,黄,红),当产生对象指针变化时(赋值)将对象和属性的信息追加到脏卡队列中,增长的方向是白->红,减少的方向红->白
    											  白色区域: 啥也不做
    											  绿色区域: 启动细化线程,跟新Region中的记忆集信息
    											  黄色区域: 启动所有的细化线程
    											  红色区域: 请求JVM进行GC工作,随着GC的执行,用户线程分配对象的速度减缓,细化线程清除脏卡队列的速度跟上用户线程修改引用指针的速度
    3.CSet(Collection Set): 需要进行GC的Region集合,例如youngGC时,所有的Eden和Survivor就在其中
    
    4.YoungGC: Step1 > STW,GCRoots扫描
    					 Step2 > STW,更新脏卡队列,将脏卡队列的数据消化完,保证GC时的视图和程序真实情况保持一致
    					 Step3 > 根据Rset的信息完善GCRoots
    					 Step4 > 并发标记,根据GCRoots遍历对象图,标记存活对象
    					 Step4 > STW,筛选回收
    					 							更新记录Region的回收价值(回收耗时)
    					 						  根据用户期望停顿时间,选择一定数量的Region存活对象至可用Region,情况移动后的Region
    					 						  记录对象类型(强软弱虚)
    					 Step5 > 引用处理,比如说弱引用的处理
    					 Other > G1怎么来控制YoungGC的回收时长,缩放EdenRegion的数量
    5.OldGC:  Pre 
    							> 堆占用达到45%时就会调度OldGC,这么做是由于如果当堆比较饱和时,GC(扫描)的时间较长,清理的速度跟不上分配对象的速度
    					Step1 > 执行youngGC的流程并标识将OldRegion中的GCRoots也识别出来
    					Step2 > 并发标记,根据GCRoots遍历对象图,标记存活对象，同时各个Region存活对象情况
    					Step3 > 对于没有存活对象的Region进行立即回收
    					Step4 > 对于含有部分存活对象的区域,取出1/8放入CSet,随着时间的消逝,各个Old区域存活对象越来越多,OldRegion变得难以回收,此时就进行8次MixGC(1/8 * 8)，但是无论是1/8OldRegion,还是8 * (1/8)OldRegion,在GC的过程中,符合停顿预期且空间可用的情况下就会停止
    ```

* **G1-GC参数**

  * | 参数                              | 说明                                                  |
    | --------------------------------- | ----------------------------------------------------- |
    | -Xmx512M                          | 设置最大堆大小                                        |
    | -XX:MaxGCPauseMillis=30           | 设置用户期望GC时的停顿时长,单位为ms,默认200ms         |
    | -XX:G1HeapRegionSize              | 设置Region的大小,范围在1～32MB                        |
    | -XX:InitiatingHeapOccupancyPercen | 设置当堆占用达到多是时开始并发标记并GC<br>默认值为45% |

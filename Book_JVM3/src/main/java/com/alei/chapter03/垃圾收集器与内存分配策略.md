### 垃圾收集器与内存分配策略

#### 3.1如何确定对象已死

* 引用计数: A对象引用B对象时,B对象的引用计数+1
  * 缺点: 当出现循环引用时就变得难以区分
* 可达性分析算法: 通过一系列称为"GC Roots"的对象为起始向下搜索,凡是在这条搜索路径上的皆为存活对象,反之即为垃圾对象
  * 栈帧中的局部变量表中引用的对象
  * 方法区中静态属性引用的对象
  * 方法区中常量引用的对象,StringTable
  * 本地方法栈中的JNI所引用的对象
  * JVM内部的引用,基本数据类型对应的class对象,常驻的异常,系统加载器
  * 被同步锁持有的对象(synchronized)】
  * J反应JVM内部情况的MXBean,JVMTI中注册的回调,本地代码缓存等

#### 3.2对象已死

* 从Object继承的finalize()方法是JVM留给对象的“逃生门”,如果对象被JVM第一次回收的时候,对象会被加入F-Queue队列,然后JVM调度一个低优先级的finalize线程去执行F-Queue,如果对象在被调用自身的finalize()时重新与引用链上建立起关系的话,那么JVM就不会回收该对象。但是这个finalize()只会被调用一次
  * 不确定因素:
### 垃圾收集器与内存分配策略

#### 3.1如何确定对象已死

* 引用计数: A对象引用B对象时,B对象的引用计数+1
  * 缺点: 当出现循环引用时就变得难以区分
* 可达性分析算法: 通过一系列称为"GC Roots"的对象为起始向下搜索,凡是在这条搜索路径上的皆为存活对象,反之即为垃圾对象
  * 栈帧中的局部变量表中引用的对象
  * 方法区中静态属性引用的对象
  * 方法区中常量引用的对象,StringTable
  * 本地方法栈中的JNI所引用的对象
  * JVM内部的引用,基本数据类型对应的class对象,常驻的异常,系统加载器
  * 被同步锁持有的对象(synchronized)】
  * J反应JVM内部情况的MXBean,JVMTI中注册的回调,本地代码缓存等

#### 3.2对象已死

* 当对象被JVM第一次标记为需要被回收时,会判断是否需要执行finalize(),如果对象需要执行finalize()，就将其加入到F-Queue队列中,交由JVM自动建立的,低优先级的Finalizer线程去执行它的finalize(),如果这个对象此时与GCRoots引用链重新建立起关联的话,那么在JVM对F-Queue的第二次小规模标记中从“即将回收”的集合移除出去
  * 是否有必要执行finalize(): 对象是否重写finalize()，对象是否已经被虚拟机调用过
  * finalize的不保证执行结束: 假设某个对象的finalize()是一个死循环,那么将导致整个finalizer线程无法正常执行

#### 3.3回收方法区

**回收方法区内的类型**

* 该类的所有实例均被回收: 没有任何该类及其子类的实例
* 加载该类的类加载器已经被回收
* 该类对应的java.lang.Class对象没有被任何地方所引用,也就是无法在任何地方通过反射访问该类

#### 3.4垃圾收集算法

* 分代收集假说

  * 弱分代假说: 大多数的对象是朝生夕死的
  * 强分代假说: 熬过越多次GC的对象就越难以消亡
  * 跨代引用假说: 跨代引用相对于同代引用来说占极少数(存在引用关系的两个对象应当趋向于一起出生一起消亡)

* GC分类

  * MinorGC/YoungGC: 年轻代GC
  * MajorGC/OldGC: 老年代GC
  * MixGC: 整个年轻代与部分老年代GC
  * FullGC: 整堆GC

* GC算法

  * 标记-清除: 缺点在于如果大量对象需要进行清理的话就需要进行大量的标记和清除动作,**会造成大量的内存碎片**

  * 标记-复制算法: 缺点如果大量对象存活那么就需要移动大量对象,**需要开辟额外的空间来进行对象复制**

  * 标记-整理: 相比“标记-清除”,避免了内存碎片的问题,**但也增加了GC时的指针转移维护成本**

  * ```txt
    标记-清除与标记-整理相比: 前者的高效体现在GC时(直接清除,不需要维护指针转移的负担),后者的高效体现在分配内存时(规整的内存空间,不需要维护空闲列表)。但是对于大多数应用来说,程序大部分时间是在和内存打交道而不是GC,而程序的吞吐量也就受限于分配内存时的效率了。
    
    CMS采取了一种和稀泥的方式,在程序运行的大部分时间内,采取了标记-清除,而在内存不足以分配对象时,在调度parallel进行标记-整理
    ```

  #### HotSpot算法实现
  
  * 根节点枚举--OopMap
    * 如果再进行GC时才从全局性引用中去获取GCRoots,那么会导致STW的时间变得漫长,所以HotSpot采取了OopMap的解决方案。但执行线程达到安全点时,记录每个栈帧上的Oop(普通对象指针)变化情况。这样就避免在GC时从方法区等GCRoots开始查找,直接从OopMap中开始遍历。
    
  * 安全点
    
    * 为每条指令生成OopMap记录是耗时耗内存的行为,所以合理的方式是以一定的间隔来执行OopMap记录扫描
    * 何时才是记录OopMap的时机?不让用户线程有明显感知的时候
      * 方法跳转,不定循环,异常跳转
    * 到了安全点之后如何记录OopMap?
      * 抢先式中断: 首先暂停所有用户线程,再检查用户线程是否到达安全点,如果没到达就恢复线程运行值安全点
      * 主动式中断: 当GC线程需要进行GC时设置标志位,用户线程在执行的过程中不断轮询该标志位
        * 轮询的位置与安全点重合,附加在堆上分配内存的时候(new 。。。)
        * 如果设置了该标志位,则触发Os的缺页异常,由中断处理程序挂起该线程
    
  * 安全区
    
    * 对于不处于运行状态的线程(sleep,wait)如何操作？
      * 即将进入安全区的用户线程开始记录OopMap,离开安全区(恢复线程执行)的时候检测GC线程是否需要STW
    
  * 记忆集和卡表
    
    * 卡表是记忆集的一种实现方式
    
    * 记忆集记录了非收集区域指向收集区域的信息
    
      ```
      假设非收集区域Area_A存在对象A,其存在跨代引用,A在堆中的地址位0X0000 0001,
      那么该区域的卡表CARD_TABLE[0X0000 0001>n]=1,标记为存在跨代引用
      那么当其他收集区域发生GC时只需要将该Area_A所标识出的卡页包含的对象进行扫描即刻,可不需要对整个Area_A进行扫描
      ```
    
    * 如何维护卡表: 采用写屏障(类AOP的方式),当执行赋值命令时采取AOP的方式标记卡表
    
  * 三色标记:
    
    * ```
      白色: 该对象未被垃圾收集器标记过
      黑色: 已经被垃圾收集器标记过,且所有字段都已被扫描
      灰色: 已经被垃圾收集器标记过,但是至少一个字段引用未被扫描
      ```
    
    * 浮动垃圾: 在用户线程与GC线程并发执行的过程中,标记为黑色的对象,与引用链上失去联系,按道理应该被清除,但是不清楚也没关系,只不过浪费了内存,但是不会对程序造成影响
    
    * 存活对象标记为垃圾: 这种情况存在与用户线程并发执行的过程中,1)黑色对象重新指向了一个白色对象,并且2)灰色对象删除对白色对象的引用
    
      * 增量更新: 破坏第一个条件,当产生黑色对象指向白色对象的引用时,讲该黑色对象记录下来,等并发扫描结束时,再以这些被记录的黑色对象为根在扫描一次
      * 原始快照: 破坏第二个条件,当灰色对象删除对白色对象的引用时。将这个要删除的引用关系记录下来,等并发扫描结束之后,对这些记录下来引用关系的灰色对象为根重新扫描一遍(怎么来理解？ 就相当于本来是要废弃从灰色对象到白色对象的引用关系的,但是GC此时利用写前屏障将本该删除的引用关系保留下来,然后等并发扫描结束,重新沿着这条本该被废弃的路径重新扫描一遍,就相当于保存了最开始的那一份副本,也必不可免的产生了浮动垃圾)

#### 3.5垃圾收集器

**serial: **使用单CPU单线程的GC收集

**ParNew:** 可使用多核心,多线程的并行GC收集,但是在单核物理机上,他的性能并不比serial高(线程上下文切换的性能损耗)

**Parallel Scavenge: **大部分的功能与ParNew类似,但是这是一款更加关注与程序吞吐量的GC,怎么来理解呢,就是当设置**-XX:+UseAdaptiveSizePolicy**时,GC将动态调整新生代大小,eden与Survivor的比例,晋升老年代对象大小的参数以达到较高的吞吐量 => 如果eden较大,虽然STW的时常更长,但是GC的次数也变少了。晋升老年代的年龄变小了,那新生代保留的存活对象是不是少了 => 这是举了一些特例,实际情况需要结合具体数值进行计算,但是大体上是这样的


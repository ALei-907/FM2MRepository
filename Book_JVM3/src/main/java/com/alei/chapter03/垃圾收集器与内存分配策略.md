### 垃圾收集器与内存分配策略

#### 3.1如何确定对象已死

* 引用计数: A对象引用B对象时,B对象的引用计数+1
  * 缺点: 当出现循环引用时就变得难以区分
* 可达性分析算法: 通过一系列称为"GC Roots"的对象为起始向下搜索,凡是在这条搜索路径上的皆为存活对象,反之即为垃圾对象
  * 栈帧中的局部变量表中引用的对象
  * 方法区中静态属性引用的对象
  * 方法区中常量引用的对象,StringTable
  * 本地方法栈中的JNI所引用的对象
  * JVM内部的引用,基本数据类型对应的class对象,常驻的异常,系统加载器
  * 被同步锁持有的对象(synchronized)】
  * J反应JVM内部情况的MXBean,JVMTI中注册的回调,本地代码缓存等

#### 3.2对象已死

* 当对象被JVM第一次标记为需要被回收时,会判断是否需要执行finalize(),如果对象需要执行finalize()，就将其加入到F-Queue队列中,交由JVM自动建立的,低优先级的Finalizer线程去执行它的finalize(),如果这个对象此时与GCRoots引用链重新建立起关联的话,那么在JVM对F-Queue的第二次小规模标记中从“即将回收”的集合移除出去
  * 是否有必要执行finalize(): 对象是否重写finalize()，对象是否已经被虚拟机调用过
  * finalize的不保证执行结束: 假设某个对象的finalize()是一个死循环,那么将导致整个finalizer线程无法正常执行

#### 3.3回收方法区

**回收方法区内的类型**

* 该类的所有实例均被回收: 没有任何该类及其子类的实例
* 加载该类的类加载器已经被回收
* 该类对应的java.lang.Class对象没有被任何地方所引用,也就是无法在任何地方通过反射访问该类

#### 3.4垃圾收集算法

* 分代收集假说

  * 弱分代假说: 大多数的对象是朝生夕死的
  * 强分代假说: 熬过越多次GC的对象就越难以消亡
  * 跨代引用假说: 跨代引用相对于同代引用来说占极少数(存在引用关系的两个对象应当趋向于一起出生一起消亡)

* GC分类

  * MinorGC/YoungGC: 年轻代GC
  * MajorGC/OldGC: 老年代GC
  * MixGC: 整个年轻代与部分老年代GC
  * FullGC: 整堆GC

* GC算法

  * 标记-清除: 缺点在于如果大量对象需要进行清理的话就需要进行大量的标记和清除动作,**会造成大量的内存碎片**

  * 标记-复制算法: 缺点如果大量对象存活那么就需要移动大量对象,**需要开辟额外的空间来进行对象复制**

  * 标记-整理: 相比“标记-清除”,避免了内存碎片的问题,**但也增加了GC时的指针转移维护成本**

  * ```txt
    标记-清除与标记-整理相比: 前者的高效体现在GC时(直接清除,不需要维护指针转移的负担),后者的高效体现在分配内存时(规整的内存空间,不需要维护空闲列表)。但是对于大多数应用来说,程序大部分时间是在和内存打交道而不是GC,而程序的吞吐量也就受限于分配内存时的效率了。
    
    CMS采取了一种和稀泥的方式,在程序运行的大部分时间内,采取了标记-清除,而在内存不足以分配对象时,在调度parallel进行标记-整理
    ```

  #### HotSpot算法实现
  
  * 根节点枚举--OopMap
    * 如果再进行GC时才从全局性引用中去获取GCRoots,那么会导致STW的时间变得漫长,所以HotSpot采取了OopMap的解决方案。但执行线程达到安全点时,记录每个栈帧上的Oop(普通对象指针)变化情况。这样就避免在GC时从方法区等GCRoots开始查找,直接从OopMap中开始遍历。
    
  * 安全点
    
    * 为每条指令生成OopMap记录是耗时耗内存的行为,所以合理的方式是以一定的间隔来执行OopMap记录扫描
    * 何时才是记录OopMap的时机?不让用户线程有明显感知的时候
      * 方法跳转,不定循环,异常跳转
    * 到了安全点之后如何记录OopMap?
      * 抢先式中断: 首先暂停所有用户线程,再检查用户线程是否到达安全点,如果没到达就恢复线程运行值安全点
      * 主动式中断: 当GC线程需要进行GC时设置标志位,用户线程在执行的过程中不断轮询该标志位
        * 轮询的位置与安全点重合,附加在堆上分配内存的时候(new 。。。)
        * 如果设置了该标志位,则触发Os的缺页异常,由中断处理程序挂起该线程
    
  * 安全区
    
    * 对于不处于运行状态的线程(sleep,wait)如何操作？
      * 即将进入安全区的用户线程开始记录OopMap,离开安全区(恢复线程执行)的时候检测GC线程是否需要STW
    
  * 记忆集和卡表
    
    * 卡表是记忆集的一种实现方式
    
    * 记忆集记录了非收集区域指向收集区域的信息
    
      ```
      假设非收集区域Area_A存在对象A,其存在跨代引用,A在堆中的地址位0X0000 0001,
      那么该区域的卡表CARD_TABLE[0X0000 0001>n]=1,标记为存在跨代引用
      那么当其他收集区域发生GC时只需要将该Area_A所标识出的卡页包含的对象进行扫描即刻,可不需要对整个Area_A进行扫描
      ```
    
      
package com.alei.zcr.chapter_2;

/**
 * @author LeiLiMin
 * @date: 2022/8/15
 * 第二章: Java内存区域与内存溢出异常
 */
public class JavaMemArea {
    public static void main(String[] args) {
        /**
         * === 程序计数器: 线程私有 ===
         * 释义: 线程是由Cpu分配时间片进行轮流切换执行,程序计数器记录着
         *  -> 正在执行的虚拟机字节码指令的地址
         *  -> 如果正在执行native方法,计数器为空值
         *  -> 在《java虚拟机规范》中,没有规定任何的OOM的情况
         *
         * === Java虚拟机栈: 线程私有 ===
         * 释义: 描述的是Java方法执行的线程内存模型
         *  -> 每个方法在执行的时候,就会同步创建一个栈帧(存储着: 局部变量表,操作数栈,动态链接,方法出口)
         *  -> 栈帧: 方法从调用到执行完毕的过程,也就是该栈帧从"入栈到出栈"的过程
         *  -> 栈帧-局部变量表: 存放着编译期可知的Java基本数据类型(String 并不是!)
         *                    对象引用: 不是对象本身,而是对象的收地址指针 | 代表对象的句柄
         *                    returnAddress类型(指向了一条字节码指令的地址)
         *  -> 栈帧-局部变量表-变量槽(slot): 局部变量表中的空间表示
         *                                64位的long和double占用2个slot
         *                                其他数据类型仅占用一个
         *  -> 调用栈超出了虚拟机所允许的深度: StackOverflowError
         *     虚拟机如果支持动态扩展,且扩展时无法申请到足够的内存: OOM
         *     HotSpot并不支持动态扩展
         *
         *  === 本地方法栈: 线程私有 ===
         *  释义: 发挥的作用与Java虚拟机栈类似,区别在于本地方法栈是为虚拟机使用到的本地方法服务的
         *  -> 一样也会抛出: OOM或者StackOverflowError
         *
         *  === Java堆: 线程共享 ===
         *  释义: 存放对象实例
         *  ->: 从分配的角度上来看,共享的Java堆中可以划分出多个线程私有的分配缓冲区(TLAB)用来提升分配效率
         *  ->: 当Java堆中没有内存完成实例分配,并且堆也无法扩展时抛出OOM
         *
         *  === Java堆方法区(Non-Heap): 线程共享 ===
         *  释义： 存储被虚拟机加载的类型信息,常量,静态变量,JIT编译后的代码缓存等数据
         *  -> 永久代是方法区的一种实现方式,选择像管理Java堆一样管理方法区,将信息记录在JVM的内存中
         *  -> 元空间也是方法区的一种实现: 使用本地内存来实现方法区
         *                            JDK6: 准备计划废弃永久代
         *                            JDK7: 将原本放在永久代的字符串常量池和静态变量转移至Java堆中
         *                            JDK8: 完全废弃永久代,使用本地内存实现元空间,将JDK7永久代中剩余的内容(主要是类信息)转移至元空间
         */

        /**
         * 运行时常量池: 用于存放编译期生成的各种字面量和符号引用
         * JVM如何给对象分配内存: 其实取决与GC,如果GC后的内存区域是规整的那么可以使用指针碰撞的方式进行
         *                                如果是不规整的,那么可以使用空闲列表的方式
         */

        /**
         * 对象的内存布局: 对象在堆内存中的存储布局可以划分为3个部分(对象头,实例数据,对齐填充(有别与C中的对齐))
         * 对象头所存储的信息: 第一类: Mark Word(HashCode,GC分代年龄,锁标识位,线程持有锁,偏向线程ID,偏向时间戳等)
         *                  第二类: 类型指针(对象指向它的类型元数据的指针,通过该指针可以确定对象是哪个类的实例)
         *                         如果对象是数组,那么在对象头还必须有一块用于记录数组长度的指针
         * 实例数据: 即在程序中定义的各种类型的字段内容无论是从父类继承下来的,还是在子类中定义的字段都必须记录起来
         * 对齐填充: HotSpot虚拟机得自动内存管理系统要求对象首地址必须是8字节的整数倍,也就是对象的大小必须是8字节的整数倍
         *         这里的"对齐填充": 指代的是填充的过程
         *         而对齐填充的意义: 就如CPrimerPlus中描述的一样,不同的硬件设备的寻址方式不一致导致的效率问题
         */
    }
}

package com.alei.zcr.chapter_2;

/**
 * @author LeiLiMin
 * @date: 2022/8/15
 * 第二章: Java内存区域与内存溢出异常
 */
public class JavaMemArea {
    public static void main(String[] args) {
        /**
         * === 程序计数器: 线程私有 ===
         * 释义: 线程是由Cpu分配时间片进行轮流切换执行,程序计数器记录着
         *  -> 正在执行的虚拟机字节码指令的地址
         *  -> 如果正在执行native方法,计数器为空值
         *  -> 在《java虚拟机规范》中,没有规定任何的OOM的情况
         *
         * === Java虚拟机栈: 线程私有 ===
         * 释义: 描述的是Java方法执行的线程内存模型
         *  -> 每个方法在执行的时候,就会同步创建一个栈帧(存储着: 局部变量表,操作数栈,动态链接,方法出口)
         *  -> 栈帧: 方法从调用到执行完毕的过程,也就是该栈帧从"入栈到出栈"的过程
         *  -> 栈帧-局部变量表: 存放着编译期可知的Java基本数据类型(String 并不是!)
         *                    对象引用: 不是对象本身,而是对象的收地址指针 | 代表对象的句柄
         *                    returnAddress类型(指向了一条字节码指令的地址)
         *  -> 栈帧-局部变量表-变量槽(slot): 局部变量表中的空间表示
         *                                64位的long和double占用2个slot
         *                                其他数据类型仅占用一个
         *  -> 调用栈超出了虚拟机所允许的深度: StackOverflowError
         *     虚拟机如果支持动态扩展,且扩展时无法申请到足够的内存: OOM
         *
         *  === 本地方法栈: 线程私有 ===
         *  释义: 发挥的作用与Java虚拟机栈类似,区别在于本地方法栈是为虚拟机使用到的本地方法服务的
         *  -> 一样也会抛出: OOM或者StackOverflowError
         *
         *  === Java堆: 线程共享 ===
         *  释义: 存放对象实例
         *  ->: 从分配的角度上来看,共享的Java堆中可以划分出多个线程私有的分配缓冲区(TLAB)用来提升分配效率
         *  ->: 当Java堆中没有内存完成实例分配,并且堆也无法扩展时抛出OOM
         *
         *  === Java堆方法区(Non-Heap): 线程共享 ===
         *  释义： 存储被虚拟机加载的类型信息,常量,静态变量,JIT编译后的代码缓存等数据
         *  -> 永久代是方法区的一种实现方式,选择像管理Java堆一样管理方法区,将信息记录在JVM的内存中
         *  -> 元空间也是方法区的一种实现: 使用本地内存来实现方法区
         *                            JDK6: 准备计划废弃永久代
         *                            JDK7: 将原本放在永久代的字符串常量池和静态变量转移至Java堆中
         *                            JDK8: 完全废弃永久代,使用本地内存实现元空间,将JDK7永久代中剩余的内容(主要是类信息)转移至元空间
         */
    }
}

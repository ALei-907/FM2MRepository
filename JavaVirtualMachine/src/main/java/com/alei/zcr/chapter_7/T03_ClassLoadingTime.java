package com.alei.zcr.chapter_7;

/**
 * @author LeiLiMin
 * @date: 2022/8/22
 */
public class T03_ClassLoadingTime {
    /**
     * 类加载阶段需要完成三件事
     * 1)通过一个类的全限定名来获取定义此类的二进制字节流
     * 2)将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
     * 3)在内存中生成一个代表这个类的java.lang.Class对象,作为方法区这个类的各种数据的访问入口
     */
    /**
     * 验证阶段:
     * 1)文件格式验证: 魔术字段是否正常等等
     * 2)元数据验证: 是否实现父类或者接口中规定必须要实现的方法等等(会触发其他类的加载,验证)
     * 3)字节码验证: 不允许在操作栈放置一个int类型数据然后以long类型来加载入本地变量等等
     * 4)符号引用验证: 发生在虚拟机将符号引用转为直接引用时进行,是否缺少或者禁止访问它依赖的某些外部类,方法,字段等资源
     * 准备阶段:
     * 1)为"类变量"分配内存并赋予默认零值
     * 解析阶段: Java虚拟机将常量池内的符号引用替换为直接引用的过程
     *          类 或者 接口的解析: 如果不是一个数组类型,有当前所在类的类加载器根据该类型进行类加载
     *                           如果是一个数组类型,先加载该数组元素类型,再由虚拟机生成一个代表该数组维度和元素的数组类型
     *          字段解析: 先对该符号引用进行解析,假设解析后为C
     *                   如果C包含了该字段的简单名称和字段描述符则返回该字段的直接引用
     *                   否则,先按从下到上的关系从父接口中查找,如果查找到就返回该字段的引用
     *                   否则,从父类中查找,如果找到了就返回
     *                   否则抛出NoSuchFieldError
     *                   最后进行权限检验
     *         方法解析与接口方法解析: TODO
     * 初始化阶段: 将所有的"类变量"和静态代码块一块组成为<cinit>()按照从上到下的顺序执行
     *           静态代码块只能访问到敬意在静态语句块之前的变量,定义在其之后的变量,只能赋值不能访问
     *           类在执行<cinit>()之前需要先执行父类的<cinit>()
     *           接口不需要先执行父接口的<cinit>()只有父接口定义的类变量被使用时,父接口才会被初始化
     *
     *           Java虚拟机保证一个类的<cinit>()在多线程环境下被正确的同步解锁,如果多线程同时去初始一个类,那么只会有其中一个线程去执行<cinit>()
     *
     */
    public static void main(String[] args) {
    }
}


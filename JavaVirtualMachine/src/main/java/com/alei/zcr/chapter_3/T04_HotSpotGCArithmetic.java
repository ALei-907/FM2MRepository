package com.alei.zcr.chapter_3;

/**
 * @author LeiLiMin
 * @date: 2022/8/16
 * HotSpot的GC算法实现
 */
public class T04_HotSpotGCArithmetic {
    /**
     * 安全点:
     * 释义: 只有用户成勋执行到达安全点之后才能够暂停以进行GC
     * > 指令序列的复用是安全点最明显的特征
     *   所以方法调用,循环跳转,异常跳转都属于指令复用,可用作安全点
     *
     * 抢先式中断: 当垃圾收集发生时,首先要中断所有用户线程。然后将那些没运行至安全点的线程恢复执行至安全点
     * 主动式中断: 当垃圾收集发生时,设置一个标识位,
     *           各个线程在执行的时候不断的主动轮询该标志位
     *           一旦发现设置了该标志位,就在最近的安全点上主动中断挂起
     *           轮询时机:
     *              > 安全点
     *              > 创建对象,或者需要在Java堆上分配内存的地方。原因就是防止没有足够的内存分配新对象
     *           实现方式:
     *              > 自陷异常信号(Linux的异常中断处理)
     *              > 将0x160100的内存页设置为不可读
     *              > 当线程想要去读取该标志位时就陷入异常,然后调度预先注册好的异常处理器挂起线程实现等待
     */

    /**
     * 记忆集: 一种抽象的结构用于记录从非收集区域指向收集区域的指针集合
     * 卡表: 是记忆集的一种实现
     *       > 卡表的实现为一个数组
     *       > 数组的一个元素标识着一片内存区域
     *       > 如果该内存区域上存在跨代引用,就标记为脏
     *       > GC时将该片内存区域的对象加入GCRoots
     */

    /**
     * 三色标记：
     * 白色: 表示为垃圾收集器从未访问过的对象
     *      GC开始阶段,所有对象都是白色
     *      GC结束阶段,白色对象就是可回收对象
     * 黑色: 被扫描到,且被标识为安全存活的对象
     * 灰色: 被垃圾收集器扫描够,但是至少存在一个引用没有被访问
     *
     * 用户线程与GC标记线程并发执行带来的问题:
     *  > 本该删除的对象没被删除-浮动垃圾
     *  > 死亡对象又被引用了 - 不可预估性的错误
     * > 解决方案
     *  > 增量更新: 当黑色对象插入新的指向白色对象的引用关系时就将这个新插入的引用记录下来
     *             并发扫描结束后,再将这些记录过的引用关系中的黑色对象为根再次扫描
     *  > 原始快照: 当灰色对象要删除指向白色对象的引用时,就将这个要删除的引用记录下来。
     *             并发扫描结束之后,将记录下来的对象作为灰色对象为根再次扫描
     */

}

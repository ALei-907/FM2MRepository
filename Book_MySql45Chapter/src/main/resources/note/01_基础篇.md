### 基础篇

#### 基础架构：一条SQL查询语句是如何执行的？

* 基础架构

  * 连接器：建立TCP链接之后,进行权限校验,权限校验通过之后,后续的操作便不再校验权限。如果使用短链接，那么频繁建立链接的的代价比较高。如果使用长链接会导致执行语句时所用到的临时内存都管理在链接对象中,这些资源会在链接断开的时候才释放,所以会导致MySql内存占用涨的很快

    解决方案: 

    ​		1)定期断开连接,或者程序中判断经过一次大内存占用的查询后断开连接。

    ​		2)MySQL 5.7 或更新版本，可以在每次执行一个比较大的操作后，通过执行 mysql_reset_connection 来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态)。

  * Server层：分析器,优化器,指向器(由于查询缓存在8.0之后整块删除了,所以就不做研究了)

    * 分析器: 对SQL进行词法分析,语法分析
    * 优化器: 经过分析器对Sql的分析校验,对SQL语句进行性能优化
    * 执行器: 判断用户是否具备对该表的查询权限。如果具备查询权限那么将调用存储引擎接口从第一行开始取数据,如果数据符合查询要求就加入结果集

  * 存储引擎：插件式支持Innodb,MyISAM,Memory

    ![1_architecture](../image/1_architecture.png)

**SQL_Node**

| Sql                                 | 释义                        |
| ----------------------------------- | --------------------------- |
| mysql -h ip -P port -u user -p      | 远程连接Mysql               |
| show processlist                    | 查看当前Mysql的所有连接信息 |
| show variables like 'wait_timeout'; | 查看默认断开链接时间        |

#### 日志系统：一条SQL更新语句是如何执行的？

* 执行器先从引擎存储指定数据行,如果数据存在内存中那么直接返回给执行器，如果不存在先从磁盘加载到内存,再返回给执行器。

* 执行器对数据进行更新操作之后,调用存储引擎接口写入数据

* 存储引擎将更新操作记录在redo log里，此时redo log的状态为prepare，然后告诉执行器执行完成，可以提交事物

* 执行器生成BinLog,并把binlog写入磁盘

* 执行器调用存储引擎的提交事物接口,将刚刚prepare的redolog修改为提交(commit)，更新完成

  ![1_updateWorkFlow](../image/1_updateWorkFlow.png)

* redolog与binlog的区别
  * redolog是innbodb独有的存储引擎层日志,存储的是物理页上的修改,采用的是循环写入的方式
  * binlog是mysql通用的Server层日志,存储的是逻辑日志,采用的是追加写
* 为什么需要2阶段提交?为了保证数据一致性
  * 当需要进行数据修复备份或者主从库复制时,如果采用先写一个再写一个的方式会导致以下问题
    * 先写redo再写binlog: redo记录了最新的操作,但是binlog由于cash丢失了该数据,进行数据恢复时使用binlog进行恢复,这就导致了恢复后的数据与redo不一致
    * 先写binlog再写redo: binlog记录了最新的操作,但是redo由于cash丢失了数据,进行数据恢复时使用binlog进行恢复,导致binlog使用最新的数据进行恢复,但是redo中持有的是旧数据,所以数据库还是不一致
* 为什么需要redolog？
  * 如果每次更新都是直接进行磁盘IO的话那么就导致出现大量的随机IO大大降低了性能,如果使用的是redolog,每次在固定的内存块上顺序的记录着各个物理页需要进行的数据修改,那么性能就得到了提升,后续只需要等mysql不那么繁忙的时候将redo上的日志更新至磁盘即可